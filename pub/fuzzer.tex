% vim: spell
\documentclass[10pt]{sigplanconf}

% The following \documentclass options may be useful:
%
% 10pt   To set in 10-point type instead of 9-point.
% 11pt   To set in 11-point type instead of 9-point.
% authoryear To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{bbding}
\usepackage{pifont}
\usepackage{url}

\begin{document}

\conferenceinfo{PLATEAU '12}{October 21, Tucson (AZ)} 
\copyrightyear{2012} 
\copyrightdata{[to be supplied]}

%\titlebanner{banner above paper title}  % These are ignored unless
%\preprintfooter{short description of paper} % 'preprint' option specified.

\title{Programming Languages vs. Fat Fingers}
\subtitle{An Empirical Study}

\authorinfo{Diomidis Spinellis\and Vassilios Karakoidas}
   {Athens University of Economics and Business}
   {\{dds, bkarak\}@aueb.gr}

\maketitle

\begin{abstract}
We explore how programs written in ten popular programming languages
are affected by small changes of their source code.
This allows us to analyze the extend to which these languages
can detect simple errors at compile or at run time.
Our study is based on a large corpus of programs written in several programming
languages systematically perturbed using a mutation-based fuzz generator.
We found ... % XXX
\end{abstract}

\category{CR-number}{subcategory}{third-level}

\terms
term1, term2

\keywords
Programming Languages, Compiler, Fuzzing, Unit Testing

\section{Introduction} % {{{1
A substitution of a comma with a period in project Mercury's working
{\sc fortran} code compromised the accuracy of the results,
rendering them unsuitable for longer orbital missions \cite{Brad89,Neu95}.
How probable are such events and how does a programming language's
design affect their likelihood and severity?

To study these questions we chose ten popular programming languages,
and a corpus of programs written in all of them.
We then constructed a source code mutation {\em fuzzer}:
a tool that systematically introduces diverse random perturbations
into the program's source code,
and examined whether the resultant source code had errors that
were detected at compile or runtime, and whether it produced
erroneous results.

In practice,
the errors that we artificially introduced into the source code can
crop up in a number of ways.
Mistyping---the ``fat fingers'' syndrome-- is one plausible source.
Other scenarios include
absent-mindedness,
automated refactorings gone awry
(especially in languages where such tasks cannot be reliably implemented),
unintended consequences from complex editor commands or
search-and-replace operations,
and even the odd cat walking over the keyboard.

The contribution of our work is twofold.
First, we describe a method for systematically evaluating the tolerance
of source code written in diverse programming languages to a particular
class of errors.
In addition, we apply this method to numerous tasks written in ten popular
programming languages,
and by analyzing tens of thousands of cases we present an overview of
the likelihood and impact of these errors among diverse languages.

In the remainder of this paper we present our
methods (Section~\ref{sec:method}) and
results (Section~\ref{sec:results}),
we discuss our findings (Section~\ref{sec:discussion}),
compare our approach against related work
(Section~\ref{sec:related}),
and conclude with proposals for further work
(Section~\ref{sec:conclusions}).

\section{Methodology} % {{{1
\label{sec:method}

We selected the languages to test based on a number of sources
collated in an {\sc ieee} Spectrum article \cite{Kin11}:
an index created by
{\sc tiobe}\footnote{\url{http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html}} (a software research firm),
the number of book titles listed on Powell's Books,
references in online discussions on {\sc irc}, and
number of job posts on Craigslist.
From the superset of the popular languages listed in those
sources we excluded
Actionscript, Visual Basic, {\sc sql}, Objective C, and the Unix shell,
because the corresponding programs or infrastructure would not match our methods.
According to the source composition,
our language coverage ranges from 71\% to 86\% of all languages.
The list of languages we used in our study and the
particular implementations we used are listed in
Table~\ref{tab:langs}.

% FuzzIdentifierSubstitution', 'FuzzIntegerPerturbation', 'FuzzRandomCharacterSubstitution', 'FuzzRandomTokenSubstitution', 'FuzzSimilarSubstitution'
\begin{description}
	\item [IdentifierSubstitution (IdSub)]
	\item [IntegerPerturbation (IntPert)]
	\item [RandomCharacterSubstitution (RandCharSub)]
	\item [RandomTokenSubstitution (RandTokenSub)] Replace one random token with another. This simulates abbsent-mindendness
	\item [SimilarSubstitution (SimSub)]
\end{description}

the fuzzer result is deterministic? Each time we executed the fuzzer to the source, it produces the same permutation of the code?

We measure:

\begin{itemize}
	\item Compilation Success Rate (com): if the a project with the specified fuzzer fails to compile.
	\item Execution Success Rate (run): if the program is executing correctly (without crashing)
	\item Output Validity Success Rate (out): if the program is not producing the proper result
\end{itemize}

\begin{table}
\begin{center}
\begin{tabular}{ l l}
 \hline
Language & Implementation \\
\hline
C 			& gcc 4.4.5 \\
C++ 		& g++ 4.4.5 \\
C\# 		& mono 2.6.7, CLI v2.0 \\
Haskell 	& ghc 6.12.1 \\
Java 		& OpenJDK 1.6.0\_18 \\
Javascript 	& spidermonkey 1.8.0 \\
PHP 		& PHP 5.3.3-7 \\
Perl 		& perl 5.10.1 \\
Python 		& python 2.6.6 \\
Ruby 		& ruby 1.5.8 \\
\hline
\end{tabular}
\end{center}
\caption{Tested languages.}
\label{tab:langs}
\end{table}

\begin{table}
\begin{center}
\begin{tabular}{ l p{5cm}}
 \hline
Task Name & Description\\
\hline
AccumFactory & Accumulator Generator as described by Paul Graham\footnote{\url{http://paulgraham.com/accgensub.html}}\\
Beers & A program that prints the ``99 bottles of beer on the wall'' song\footnote{\url{http://99-bottles-of-beer.net/}}.\\
Dow & Detects all years (in a range) that christmas is a Sunday.\\
FlatList & Flattens a series of nested lists.\\
FuncComp & Implementation of mathematical function composition.\\
Horner & Horner's rule for polynomial evaluation.\\
Hello & A typical ``hello, world!'' program.\\
Mult & Ethiopian Multiplication. A method to multiply integers using only addition, doubling and halving.\\
MutRecursion & Hofstadter Female and Male sequences\footnote{\url{http://en.wikipedia.org/wiki/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences}}.\\
ManBoy & \textit{Man or Boy} test as proposed by Don Knuth.\\
Power & Implementation of Power sets\footnote{\url{http://en.wikipedia.org/wiki/Power_set}}.\\
Substring & A program that count the occurrences of a substring.\\
Tokenizer & A string tokenizing program.\\
ZigZag & Implementation of a program that produces a zig-zag array\footnote{\url{http://rosettacode.org/wiki/Zig-zag_matrix}}.\\
\hline
\end{tabular}
\end{center}
\caption{List of selected Rosseta Code tasks.}
\label{tab:Tasks}
\end{table}

Fuzzing types

% FuzzIdentifierSubstitution', 'FuzzIntegerPerturbation', 'FuzzRandomCharacterSubstitution', 'FuzzRandomTokenSubstitution', 'FuzzSimilarSubstitution'
\begin{description}
	\item [IdentifierSubstitution (IdSub)]
	\item [IntegerPerturbation (IntPert)]
	\item [RandomCharacterSubstitution (RandCharSub)]
	\item [RandomTokenSubstitution (RandTokenSub)] Replace one random token with another. This simulates abbsent-mindendness

	\item [SimilarSubstitution (SimSub)]
\end{description}

the fuzzer result is deterministic? Each time we executed the fuzzer to the source, it produces the same permutation of the code?

We measure:

\begin{itemize}
	\item Compilation Failure: if the a project with the specified fuzzer fails to compile.
	\item Execution Failure: if the program is executing correctly (without crashing)
	\item Result Error: if the program is not producing the proper result
\end{itemize}


\section{Results} % {{{1
\label{sec:results}

\begin{table*}
% ['c', 'cpp', 'cs', 'hs', 'java', 'js', 'php', 'pl', 'py', 'rb']
\begin{center}
\begin{tabular}{l c c c c c c c c c c}
 \hline
 & C & C++ & C\# & Haskell & Java & Javascript & PHP & Perl & Python & Ruby\\
\hline
AccumFactory &  &  &  &  &  &  &  &  &  &  \\
Hello &  &  &  &  &  &  &  &  &  &  \\
FlatList &  & \ding{55} & \ding{55} &  & \ding{55} &  &  &  &  &  \\
Power &  &  & \ding{55} &  &  &  &  &  &  &  \\
ZigZag &  &  & \ding{55} &  &  & \ding{55} &  &  &  &  \\
FuncComp &  &  &  &  &  &  &  &  &  &  \\
Substring &  &  &  & \ding{55} &  &  &  &  &  &  \\
ManBoy &  &  &  &  &  &  &  &  &  &  \\
Beers &  &  &  &  &  &  &  &  &  &  \\
Tokenizer &  &  &  & \ding{55} &  &  &  &  &  &  \\
Horner &  &  &  &  &  &  &  &  &  &  \\
MutRecursion &  &  &  &  &  &  &  &  &  &  \\
Dow &  &  &  &  &  &  &  &  &  &  \\
Mult &  &  &  &  &  &  &  &  &  &  \\
Total & 14 & 13 & 11 & 12 & 13 & 13 & 14 & 14 & 14 & 14 \\
\hline
\end{tabular}
\end{center}
\caption{Language Compatibility per Task.}
\label{tbl:lang-compatibility}
\end{table*}

\begin{table*}
\begin{center}
\begin{tabular}{ l r r r r r r r r r r r r r r r r r r }
 & \multicolumn{3}{c}{IdSub (\%)} & \multicolumn{3}{c}{IntPert (\%)} & \multicolumn{3}{c}{RandCharSub (\%)} & \multicolumn{3}{c}{RandTokenSub (\%)} & \multicolumn{3}{c}{SimSub (\%)}\\
 & com & run & out & com & run & out & com & run & out & com & run & out & com & run & out\\
\hline
C & 0.166 & 0.140 & 0.104  & 1.000 & 0.526 & 0.186  & 0.073 & 0.073 & 0.061  & 0.054 & 0.051 & 0.034  & 0.206 & 0.166 & 0.096 \\
C++ & 0.056 & 0.049 & 0.039  & 0.917 & 0.472 & 0.062  & 0.037 & 0.037 & 0.034  & 0.026 & 0.024 & 0.013  & 0.083 & 0.071 & 0.031 \\
C\# & 0.069 & 0.069 & 0.066  & 0.698 & 0.652 & 0.119  & 0.040 & 0.040 & 0.039  & 0.030 & 0.030 & 0.027  & 0.077 & 0.074 & 0.060 \\
Haskell & 0.040 & 0.019 & 0.004  & 0.894 & 0.840 & 0.103  & 0.037 & 0.034 & 0.023  & 0.035 & 0.032 & 0.018  & 0.134 & 0.112 & 0.021 \\
Java & 0.051 & 0.036 & 0.029  & 1.000 & 0.825 & 0.203  & 0.031 & 0.030 & 0.029  & 0.023 & 0.019 & 0.017  & 0.079 & 0.064 & 0.031 \\
Javascript & 0.659 & 0.184 & 0.057  & 1.000 & 0.797 & 0.060  & 0.309 & 0.096 & 0.079  & 0.150 & 0.057 & 0.019  & 0.572 & 0.229 & 0.051 \\
PHP & 0.564 & 0.341 & 0.030  & 0.992 & 0.875 & 0.162  & 0.374 & 0.327 & 0.019  & 0.257 & 0.237 & 0.011  & 0.462 & 0.397 & 0.014 \\
Perl & 0.579 & 0.293 & 0.074  & 1.000 & 0.910 & 0.221  & 0.151 & 0.116 & 0.067  & 0.182 & 0.142 & 0.049  & 0.443 & 0.273 & 0.105 \\
Python & 0.433 & 0.173 & 0.126  & 1.000 & 0.753 & 0.144  & 0.183 & 0.069 & 0.061  & 0.207 & 0.106 & 0.057  & 0.452 & 0.236 & 0.100 \\
Ruby & 0.523 & 0.118 & 0.091  & 1.000 & 0.911 & 0.316  & 0.276 & 0.147 & 0.123  & 0.334 & 0.158 & 0.111  & 0.580 & 0.270 & 0.161 \\
\end{tabular}
\end{center}
\caption{Aggregated results per language}
\label{tbl:aggregated-per-language}
\end{table*}

\section{Discussion} % {{{1
\label{sec:discussion}

\section{Related Work} % {{{1
\label{sec:related}

Fuzzing as a technique to investigate the reliability of software
was first proposed in an article by Miller and his colleagues~\cite{MFS90}.

In that they describe how they tested the common collection of {\sc unix}
utilities in various operating systems and architectures and discrovered that
25-33\% of these, are crashing under certain conditions. To perform these tests
they implemented automation shell scripts and a fuzzer, a program that generated
random character sequences according to certain specifications.

Fuzzing ... \cite{TJC08}, \cite{WWGZ11}

Our approach fuzzes the program with pseudo-random
perturbations based in same cases on knowledge of
lexical tokens.
This can result in a large number of failures.
An alternative approach, {\em grammar-based white box fuzzing}~\cite{God08},
takes into account the input language's grammar to fuzz the input in
ways that are syntactically correct.
This results in a higher rate of successful fuzzing and the location
of deeper problems.

Testing ... \cite{HAM06}

Fault Tolerance ... \cite{KOKR07}, \cite{LYU95}

\section{Conclusions} % {{{1
\label{sec:conclusions}


\acks

STEREO
Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{fuzzer}

% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright

%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...

%\end{thebibliography}

\end{document}
